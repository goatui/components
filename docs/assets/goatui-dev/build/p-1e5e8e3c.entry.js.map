{"version":3,"sources":["src/components/flow-designer/canvas/canvas.scss?tag=goat-canvas&encapsulation=shadow","src/components/flow-designer/canvas/canvas.tsx"],"names":["canvasCss","Canvas","[object Object]","hostRef","this","unitSize","lines","padding","drawingArea","minX","minY","maxX","maxY","computedViewbox","x","y","width","height","paths","_Canvas_createStartString","set","point","updateDrawingArea","_Canvas_createQuadraticCurveString","pointA","pointB","_Canvas_createLineString","setTimeout","renderCanvas","line","drawLine","calculateViewbox","result","viewbox","split","parseInt","startConnector","start","gap","direction","endConnector","end","pathString","__classPrivateFieldGet","call","type","createStraightLinePath","createShapeConnectorPath","push","join","curveSize","position","h","Host","class","style","background-size","background-position","viewBox","map","path","stroke-width","stroke-linecap","stroke-linejoin","stroke","d","fill"],"mappings":"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","sourcesContent":["@import \"../../../globalStyles/commons\";\r\n\r\n:host {\r\n  display: block;\r\n}\r\n\r\n.canvas-wrapper {\r\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='8d8d8d' class='bi bi-dot' viewBox='0 0 16 16'%3E%3Cpath d='M8 9.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z'/%3E%3C/svg%3E\");\r\n  width: max-content;\r\n}\r\n\r\n.line {\r\n  stroke: v(--border-color);\r\n\r\n  &.clickable {\r\n    cursor: pointer;\r\n    &:hover {\r\n      stroke: v(--color-primary);\r\n    }\r\n    z-index: 1;\r\n  }\r\n}\r\n","import { Component, Element, h, Host, Prop, State } from '@stencil/core';\r\n\r\n@Component({\r\n  tag: 'goat-canvas',\r\n  styleUrl: 'canvas.scss',\r\n  shadow: true,\r\n})\r\nexport class Canvas {\r\n\r\n  @Prop() unitSize: number = 16;\r\n  @Prop() lines: any[] = [];\r\n  @Prop() padding: number = 2;\r\n\r\n  @Prop() viewbox?: string;\r\n\r\n  private drawingArea = {\r\n    minX: 0,\r\n    minY: 0,\r\n    maxX: 0,\r\n    maxY: 0,\r\n  };\r\n\r\n  @State() computedViewbox = {\r\n    x: 0,\r\n    y: 0,\r\n    width: 0,\r\n    height: 0,\r\n  };\r\n\r\n  @State() paths: string[] = [];\r\n\r\n  @Element() elm!: HTMLElement;\r\n\r\n\r\n  componentDidLoad() {\r\n    setTimeout(() => {\r\n      this.renderCanvas();\r\n    });\r\n  }\r\n\r\n  renderCanvas() {\r\n\r\n    for (const line of this.lines) {\r\n      this.drawLine(line);\r\n    }\r\n\r\n    this.computedViewbox = this.calculateViewbox();\r\n    this.paths = [...this.paths];\r\n  }\r\n\r\n  calculateViewbox() {\r\n    let result;\r\n    if (this.viewbox) {\r\n      const viewbox = this.viewbox.split(' ');\r\n      result = {\r\n        x: parseInt(viewbox[0], 10),\r\n        y: parseInt(viewbox[1], 10),\r\n        width: parseInt(viewbox[2], 10),\r\n        height: parseInt(viewbox[3], 10),\r\n      };\r\n    } else {\r\n      result = {\r\n        x: this.drawingArea.minX,\r\n        y: this.drawingArea.minY,\r\n        width: (this.drawingArea.maxX - this.drawingArea.minX),\r\n        height: (this.drawingArea.maxY - this.drawingArea.minY),\r\n      };\r\n    }\r\n\r\n    if (this.padding) {\r\n      result.x -= this.padding;\r\n      result.y -= this.padding;\r\n      result.width += 2 * this.padding;\r\n      result.height += 2 * this.padding;\r\n    }\r\n    return result;\r\n  }\r\n\r\n\r\n  drawLine(line) {\r\n\r\n    const startConnector = {\r\n      x: line.start.x,\r\n      y: line.start.y,\r\n    };\r\n    if (line.start.gap) {\r\n      if (line.start.direction == 'down') {\r\n        startConnector.y += line.start.gap;\r\n      } else if (line.start.direction == 'up') {\r\n        startConnector.y -= line.start.gap;\r\n      } else if (line.start.direction == 'right') {\r\n        startConnector.x += line.start.gap;\r\n      } else if (line.start.direction == 'left') {\r\n        startConnector.x -= line.start.gap;\r\n      }\r\n    }\r\n\r\n    const endConnector = {\r\n      x: line.end.x,\r\n      y: line.end.y,\r\n    };\r\n\r\n    if (line.end.gap) {\r\n      if (line.end.direction == 'down') {\r\n        endConnector.y += line.end.gap;\r\n      } else if (line.end.direction == 'top') {\r\n        endConnector.y -= line.end.gap;\r\n      } else if (line.end.direction == 'right') {\r\n        endConnector.x += line.end.gap;\r\n      } else if (line.end.direction == 'left') {\r\n        endConnector.x -= line.end.gap;\r\n      }\r\n    }\r\n\r\n    let pathString = this.#createStartString(line.start);\r\n\r\n    /**\r\n     * Straight line between two connectors\r\n     */\r\n    if (!line.type || line.type == 'straight_line') {\r\n      pathString += this.createStraightLinePath(line, startConnector, endConnector);\r\n    }\r\n\r\n    if (line.type == 'shape_connector') {\r\n      pathString += this.createShapeConnectorPath(line, startConnector, endConnector);\r\n    }\r\n\r\n\r\n    this.updateDrawingArea(line.start);\r\n    this.updateDrawingArea(line.end);\r\n\r\n    this.paths.push(pathString);\r\n\r\n  }\r\n\r\n  createStraightLinePath(line, startConnector, endConnector) {\r\n    let pathString = [];\r\n    pathString.push(this.#createLineString(startConnector));\r\n    pathString.push(this.#createLineString(endConnector));\r\n    pathString.push(this.#createLineString(line.end));\r\n    return ` ${pathString.join(' ')}`;\r\n  }\r\n\r\n  createShapeConnectorPath(line, startConnector, endConnector) {\r\n\r\n    let pathString = [];\r\n    let curveSize = 2;\r\n\r\n    if (line.start.direction == 'down') {\r\n      if (line.end.direction == 'top') {\r\n        if (startConnector.x === endConnector.x) {\r\n          pathString.push(this.#createLineString(line.end));\r\n        } else if (startConnector.x < endConnector.x) {\r\n          pathString.push(this.#createLineString({ x: startConnector.x, y: startConnector.y - curveSize }));\r\n          pathString.push(this.#createQuadraticCurveString({ x: startConnector.x, y: startConnector.y },\r\n            { x: startConnector.x + curveSize, y: startConnector.y }));\r\n\r\n          pathString.push(this.#createLineString({ x: endConnector.x - curveSize, y: startConnector.y }));\r\n          pathString.push(this.#createQuadraticCurveString({ x: endConnector.x, y: startConnector.y },\r\n            { x: endConnector.x, y: startConnector.y + curveSize }));\r\n          pathString.push(this.#createLineString(line.end));\r\n        } else {\r\n          pathString.push(this.#createLineString({ x: startConnector.x, y: startConnector.y - curveSize }));\r\n          pathString.push(this.#createQuadraticCurveString({ x: startConnector.x, y: startConnector.y },\r\n            { x: startConnector.x - curveSize, y: startConnector.y }));\r\n\r\n          pathString.push(this.#createLineString({ x: endConnector.x + curveSize, y: startConnector.y }));\r\n          pathString.push(this.#createQuadraticCurveString({ x: endConnector.x, y: startConnector.y },\r\n            { x: endConnector.x, y: startConnector.y + curveSize }));\r\n          pathString.push(this.#createLineString(line.end));\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /*if (startConnector.x === endConnector.x) {\r\n      pathString.push(this.#createLineString(endConnector));\r\n    } else {\r\n      if (line.start.direction === 'down' && line.end.direction === 'left') {\r\n        if (startConnector.y < endConnector.y) {\r\n          pathString += ` ${this.#createLineString({ x: startConnector.x, y: endConnector.y })}`;\r\n        } else {\r\n          pathString += ` ${this.#createLineString({ x: endConnector.x, y: startConnector.y })}`;\r\n        }\r\n      }\r\n      pathString += ` ${this.#createLineString(endConnector)}`;\r\n    }*/\r\n    return ` ${pathString.join(' ')}`;\r\n  }\r\n\r\n\r\n  updateDrawingArea(position) {\r\n    if (position.x > this.drawingArea.maxX) {\r\n      this.drawingArea.maxX = position.x;\r\n    }\r\n    if (position.y > this.drawingArea.maxY) {\r\n      this.drawingArea.maxY = position.y;\r\n    }\r\n    if (position.x < this.drawingArea.minX) {\r\n      this.drawingArea.minX = position.x;\r\n    }\r\n    if (position.y < this.drawingArea.minY) {\r\n      this.drawingArea.minY = position.y;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return <Host>\r\n      <div class='canvas-wrapper' style={{\r\n        'background-size': `${this.unitSize}px ${this.unitSize}px`,\r\n        'background-position': `${this.unitSize / 2}px ${this.unitSize / 2}px`,\r\n      }}>\r\n\r\n        <svg class='canvas'\r\n             viewBox={`${this.computedViewbox.x * this.unitSize} ${this.computedViewbox.x * this.unitSize} ${this.computedViewbox.width * this.unitSize} ${this.computedViewbox.height * this.unitSize}`}>\r\n          {\r\n            (this.paths.map((path) => {\r\n              return <path class='line clickable'\r\n                           stroke-width='4'\r\n                           stroke-linecap='round'\r\n                           stroke-linejoin='round'\r\n                           stroke='#000'\r\n                           d={`${path}`}\r\n                           fill='none' />;\r\n            }))\r\n          }\r\n        </svg>\r\n      </div>\r\n    </Host>;\r\n  }\r\n\r\n  #createStartString: any = (point) => {\r\n    this.updateDrawingArea(point);\r\n    return `M${point.x * this.unitSize} ${point.y * this.unitSize}`;\r\n  };\r\n\r\n  #createQuadraticCurveString: any = (pointA, pointB) => {\r\n    this.updateDrawingArea(pointA);\r\n    this.updateDrawingArea(pointA);\r\n    return `Q ${pointA.x * this.unitSize} ${pointA.y * this.unitSize} ${pointB.x * this.unitSize} ${pointB.y * this.unitSize}`;\r\n  };\r\n\r\n  #createLineString: any = (point) => {\r\n    this.updateDrawingArea(point);\r\n    return `L${point.x * this.unitSize} ${point.y * this.unitSize}`;\r\n  };\r\n\r\n}\r\n"]}