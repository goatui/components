{"version":3,"names":["canvasCss","Canvas","this","drawingArea","minX","minY","maxX","maxY","unitSize","dotRadius","gap","getNextPoint","point","direction","length","nextPoint","x","y","componentDidLoad","setTimeout","renderCanvas","updateDrawingArea","position","renderShapes","computedViewbox","shapes","map","shape","type","Math","ceil","radius","width","height","h","cx","cy","r","fill","color","pathString","start","end","class","stroke","d","current","Object","assign","updateComputationArea","i","path","nextPath","midPoint","line","showArrow","dashed","padding","computationArea","render","computedViewBox","viewbox","viewBox","split","parseInt","Host","style","zoom","id","patternUnits","markerWidth","markerHeight","refX","refY","markerUnits","orient","points"],"sources":["src/components/flow-designer/canvas/canvas.scss?tag=goat-canvas&encapsulation=shadow","src/components/flow-designer/canvas/canvas.tsx"],"sourcesContent":["@import \"../../../globalStyles/commons\";\r\n\r\n:host {\r\n  display: block;\r\n}\r\n\r\n.canvas-wrapper {\r\n  background: var(--layer-hover-01);\r\n}\r\n\r\n#canvas-background circle {\r\n  fill: var(--border-disabled);\r\n}\r\n\r\n#endarrow polyline{\r\n  fill: none;\r\n  stroke: #231F20;\r\n  vector-effect: non-scaling-stroke;\r\n  stroke-width: 2;\r\n}\r\n\r\n\r\n.line {\r\n\r\n  &.no-color {\r\n    stroke: v(--border-strong-01);\r\n  }\r\n}\r\n\r\n\r\n.clickable {\r\n  cursor: pointer;\r\n\r\n  &:hover .line {\r\n\r\n    stroke: v(--color-primary);\r\n  }\r\n\r\n  z-index: 1;\r\n}\r\n","import { Component, Element, h, Host, Prop } from '@stencil/core';\r\n\r\n/**\r\n * @name Canvas\r\n * @category Up coming\r\n * @description Canvas for drawing lines and shapes on.\r\n * @img /assets/img/canvas.png\r\n */\r\n@Component({\r\n  tag: 'goat-canvas',\r\n  styleUrl: 'canvas.scss',\r\n  shadow: true,\r\n})\r\nexport class Canvas {\r\n  @Prop() shapes: any[] = [];\r\n  @Prop() padding: number = 1;\r\n  @Prop() zoom: number = 1;\r\n\r\n  @Prop() viewbox?: string;\r\n\r\n  private drawingArea = {\r\n    minX: 0,\r\n    minY: 0,\r\n    maxX: 0,\r\n    maxY: 0,\r\n  };\r\n\r\n  private unitSize: number = 1;\r\n  private dotRadius: number = this.unitSize;\r\n  private gap: number = this.unitSize * 10;\r\n\r\n  @Element() elm!: HTMLElement;\r\n\r\n  componentDidLoad() {\r\n    setTimeout(() => {\r\n      this.renderCanvas();\r\n    });\r\n  }\r\n\r\n  renderCanvas() {}\r\n\r\n  updateDrawingArea(position) {\r\n    if (position.x > this.drawingArea.maxX) {\r\n      this.drawingArea.maxX = position.x;\r\n    }\r\n    if (position.y > this.drawingArea.maxY) {\r\n      this.drawingArea.maxY = position.y;\r\n    }\r\n    if (position.x < this.drawingArea.minX) {\r\n      this.drawingArea.minX = position.x;\r\n    }\r\n    if (position.y < this.drawingArea.minY) {\r\n      this.drawingArea.minY = position.y;\r\n    }\r\n  }\r\n\r\n  renderShapes(computedViewbox) {\r\n    const dotRadius = this.unitSize;\r\n\r\n    const shapes = this.shapes.map(shape => {\r\n      switch (shape.type) {\r\n        case 'circle': {\r\n          if (shape.x + Math.ceil(shape.radius) > computedViewbox.width) {\r\n            computedViewbox.width = shape.x + Math.ceil(shape.radius);\r\n          }\r\n          if (shape.x - Math.ceil(shape.radius) < computedViewbox.x) {\r\n            computedViewbox.x = shape.x - Math.ceil(shape.radius);\r\n          }\r\n          if (shape.y + Math.ceil(shape.radius) > computedViewbox.height) {\r\n            computedViewbox.height = shape.y + Math.ceil(shape.radius);\r\n          }\r\n          if (shape.y - Math.ceil(shape.radius) < computedViewbox.y) {\r\n            computedViewbox.y = shape.y - Math.ceil(shape.radius);\r\n          }\r\n          return <circle cx={shape.x * this.gap + dotRadius} cy={shape.y * this.gap + dotRadius} r={shape.radius * this.gap} fill={shape.color || 'black'} />;\r\n        }\r\n        case 'rect': {\r\n          if (shape.x + Math.ceil(shape.width) > computedViewbox.width) {\r\n            computedViewbox.width = shape.x + Math.ceil(shape.width);\r\n          }\r\n          if (shape.x - Math.ceil(shape.width) < computedViewbox.x) {\r\n            computedViewbox.x = shape.x - Math.ceil(shape.width);\r\n          }\r\n          if (shape.y + Math.ceil(shape.height) > computedViewbox.height) {\r\n            computedViewbox.height = shape.y + Math.ceil(shape.height);\r\n          }\r\n          if (shape.y - Math.ceil(shape.height) < computedViewbox.y) {\r\n            computedViewbox.y = shape.y - Math.ceil(shape.height);\r\n          }\r\n          return (\r\n            <rect\r\n              x={shape.x * this.gap + dotRadius}\r\n              y={shape.y * this.gap}\r\n              width={shape.width * this.gap + dotRadius}\r\n              height={shape.height * this.gap + dotRadius}\r\n              fill={shape.color || 'black'}\r\n            />\r\n          );\r\n        }\r\n        case 'line': {\r\n          const pathString = `M${shape.start.x * this.gap + this.dotRadius} ${shape.start.y * this.gap + this.dotRadius} L${shape.end.x * this.gap + this.dotRadius} ${\r\n            shape.end.y * this.gap + this.dotRadius\r\n          }`;\r\n          return <path class=\"line clickable\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"#000\" d={pathString} fill=\"none\" />;\r\n        }\r\n        case 'connector': {\r\n          let pathString = `M${shape.start.x * this.gap + this.dotRadius} ${shape.start.y * this.gap + this.dotRadius}`;\r\n          let current = { ...shape.start };\r\n          this.updateComputationArea(current, computedViewbox);\r\n\r\n          for (let i = 0; i < shape.path.length; i++) {\r\n            // draw line\r\n            const path = shape.path[i];\r\n            let point: any = {};\r\n\r\n            if (i == 0) {\r\n              point = this.getNextPoint(current, path.direction, 1);\r\n              pathString += ` L${point.x * this.gap + this.dotRadius} ${point.y * this.gap + this.dotRadius}`;\r\n              current = { ...point };\r\n              this.updateComputationArea(current, computedViewbox);\r\n            }\r\n\r\n            point = this.getNextPoint(current, path.direction, path.length - 2);\r\n            pathString += ` L${point.x * this.gap + this.dotRadius} ${point.y * this.gap + this.dotRadius}`;\r\n            current = { ...point };\r\n            this.updateComputationArea(current, computedViewbox);\r\n\r\n            if (i == shape.path.length - 1) {\r\n              point = this.getNextPoint(current, path.direction, 1);\r\n              pathString += ` L${point.x * this.gap + this.dotRadius} ${point.y * this.gap + this.dotRadius}`;\r\n              current = { ...point };\r\n              this.updateComputationArea(current, computedViewbox);\r\n            } else {\r\n              // draw curve\r\n              const nextPath = shape.path[i + 1];\r\n              const midPoint: any = this.getNextPoint(current, path.direction, 1);\r\n              const nextPoint = this.getNextPoint(midPoint, nextPath.direction, 1);\r\n              pathString += ` Q ${midPoint.x * this.gap + this.dotRadius} ${midPoint.y * this.gap + this.dotRadius} ${nextPoint.x * this.gap + this.dotRadius} ${\r\n                nextPoint.y * this.gap + this.dotRadius\r\n              }`;\r\n              current = { ...nextPoint };\r\n              this.updateComputationArea(current, computedViewbox);\r\n            }\r\n          }\r\n\r\n          //draw curve\r\n\r\n          return (\r\n            <g class=\"clickable\">\r\n              <path\r\n                class={{ 'line': true, 'no-color': !shape.color }}\r\n                stroke-width=\"2\"\r\n                stroke-linecap=\"round\"\r\n                stroke-linejoin=\"round\"\r\n                stroke={shape.color || '#000'}\r\n                marker-end={shape.showArrow ? 'url(#endarrow)' : ''}\r\n                d={pathString}\r\n                stroke-dasharray={shape.dashed ? '6,6' : null}\r\n                fill=\"none\"\r\n              />\r\n              <path stroke-width=\"10\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"transparent\" d={pathString} fill=\"none\" />\r\n            </g>\r\n          );\r\n        }\r\n      }\r\n    });\r\n\r\n    // Padding\r\n    computedViewbox.x = computedViewbox.x - this.padding;\r\n    computedViewbox.y = computedViewbox.y - this.padding;\r\n    computedViewbox.width = computedViewbox.width + this.padding;\r\n    computedViewbox.height = computedViewbox.height + this.padding;\r\n\r\n    computedViewbox.width = computedViewbox.width - computedViewbox.x;\r\n    computedViewbox.height = computedViewbox.height - computedViewbox.y;\r\n\r\n    return shapes;\r\n  }\r\n\r\n  updateComputationArea(point, computationArea) {\r\n    if (point.x > computationArea.width) {\r\n      computationArea.width = point.x;\r\n    } else if (point.x < computationArea.x) {\r\n      computationArea.x = point.x;\r\n    }\r\n    if (point.y > computationArea.height) {\r\n      computationArea.height = point.y;\r\n    } else if (point.y < computationArea.y) {\r\n      computationArea.y = point.y;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const dotRadius = this.unitSize;\r\n\r\n    let computedViewBox: any = { width: 0, height: 0, x: 0, y: 0 };\r\n\r\n    const shapes = this.renderShapes(computedViewBox);\r\n\r\n    if (this.viewbox) {\r\n      const viewBox = this.viewbox.split(' ');\r\n      computedViewBox = {\r\n        x: parseInt(viewBox[0], 10),\r\n        y: parseInt(viewBox[1], 10),\r\n        width: parseInt(viewBox[2], 10),\r\n        height: parseInt(viewBox[3], 10),\r\n      };\r\n    }\r\n\r\n    return (\r\n      <Host>\r\n        <div\r\n          class=\"canvas-wrapper\"\r\n          style={{\r\n            width: (computedViewBox.width * this.gap + 2) * dotRadius * this.zoom + 'px',\r\n            height: (computedViewBox.height * this.gap + 2) * dotRadius * this.zoom + 'px',\r\n          }}\r\n        >\r\n          <svg\r\n            class=\"canvas\"\r\n            height=\"100%\"\r\n            width=\"100%\"\r\n            viewBox={`${computedViewBox.x * this.gap} ${computedViewBox.y * this.gap} ${computedViewBox.width * this.gap + 2 * dotRadius} ${\r\n              computedViewBox.height * this.gap + 2 * dotRadius\r\n            }`}\r\n          >\r\n            <defs>\r\n              <pattern id=\"canvas-background\" patternUnits=\"userSpaceOnUse\" width={this.gap} height={this.gap}>\r\n                <circle cx={1} cy={1} r={this.dotRadius} />\r\n              </pattern>\r\n\r\n              <marker id=\"endarrow\" markerWidth=\"15\" markerHeight=\"22.5\" refX=\"9\" refY=\"15\" markerUnits=\"userSpaceOnUse\" orient=\"auto\">\r\n                <polyline points=\"0 22.5, 7.5 15, 0 7.5\"></polyline>\r\n              </marker>\r\n            </defs>\r\n\r\n            <rect x={computedViewBox.x * this.gap} y={computedViewBox.y * this.gap} width=\"100%\" height=\"100%\" fill=\"url(#canvas-background)\" />\r\n\r\n            {shapes}\r\n          </svg>\r\n        </div>\r\n      </Host>\r\n    );\r\n  }\r\n\r\n  private getNextPoint = (point, direction, length) => {\r\n    const nextPoint: any = {};\r\n    if (direction == 'down') {\r\n      nextPoint.x = point.x;\r\n      nextPoint.y = point.y + length;\r\n    } else if (direction == 'up') {\r\n      nextPoint.x = point.x;\r\n      nextPoint.y = point.y - length;\r\n    } else if (direction == 'left') {\r\n      nextPoint.x = point.x - length;\r\n      nextPoint.y = point.y;\r\n    } else if (direction == 'right') {\r\n      nextPoint.x = point.x + length;\r\n      nextPoint.y = point.y;\r\n    }\r\n    return nextPoint;\r\n  };\r\n}\r\n"],"mappings":"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"}